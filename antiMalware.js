(function () {
  window.whiteList = ["app.js","antiMalware.js"];
  //network
  document._oldFetch = window.fetch;
  document._oldXHRSend = window.XMLHttpRequest.prototype.send;
  document._oldXHROpen = window.XMLHttpRequest.prototype.open;
  //storage
  document._oldCookie = document.cookie;
  document._oldGetItem = localStorage.getItem;
  //dom
  document._oldGetElementById = document.getElementById;
  document._oldQuerySelector = document.querySelector;
  document._oldQuerySelectorAll = document.querySelectorAll;
  document._oldGetElementsByClassName = document.getElementsByClassName;
  document._oldGetElementsByName = document.getElementsByName;
  document._oldGetElementsByTagName = document.getElementsByTagName;

  // document.getElementsByTagNameNS
  // document.insertBefore

  //cookie get && set 
  Object.defineProperty(document, 'cookie', {
    get: function () {
      let stack = new Error().stack || '';
      if(isAuthorized(stack,"","cookie","cookie read")){
        return document._oldCookie;
      }
    },
    set: function (val) {
      let stack = new Error().stack || '';
      if(isAuthorized(stack,"","cookie","cookie write")){
        document._oldCookie = val;
      }
    }
  });

  //getElementById override
  document.getElementById = function () {
    let stack = new Error().stack || '';
    const isValid = stackValidator(stack, "getElementById");
    const logger = document._oldGetElementById("logger_container");
    const newNode = document.createElement("div");
    let message = "";
    if (!isValid.valid) {
      newNode.classList.add("logger_blocked", "flex", "logger_row");
      message = `acess to getElementById was blocked , execute from file => ${isValid.file}`;
      return null;
    } else {
      newNode.classList.add("logger_approved", "flex", "logger_row");
      message = `getElementById , execute from file => ${isValid.file}`;
    }
    newNode.innerHTML = message;
    logger.insertBefore(newNode, logger.firstChild);

    return document._oldGetElementById(arguments[0]);
  }

  document.querySelector = function () {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,"","querySelector","querySelector")){
      return document._oldQuerySelector.apply(this, arguments);
    }
  }

  document.querySelectorAll = function () {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,"","querySelectorAll","querySelectorAll")){
      return document._oldQuerySelectorAll.apply(this, arguments);
    }
  }

  document.getElementsByClassName = function () {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,"","getElementsByClassName","getElementsByClassName")){
      return document._oldGetElementsByClassName.apply(this, arguments);
    }
  }

  document.getElementsByName = function () {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,"","getElementsByName","getElementsByName")){
      return document._oldGetElementsByName.apply(this, arguments);
    }
  }

  document.getElementsByTagName = function () {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,"","getElementsByTagName","getElementsByTagName")){
      return document._oldGetElementsByTagName.apply(this, arguments);
    }
  }


  //localStorage override
  localStorage.getItem = function () {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,"","getItem","localStorage.getItem()")){
      return document._oldGetItem.apply(this, arguments);
    }
  }

  //ovrride fetch
  window.fetch = function () {
    const url = arguments[0];
    let stack = new Error().stack || '';
    if(isAuthorized(stack,url,"open","Fetch")){
      return document._oldFetch.apply(this, arguments);
    }

  }

  //override xhr send
  window.XMLHttpRequest.prototype.send = function () {
    //prevent if open blocked 
    if (this.readyState == 0) {
      return;
    }
    return document._oldXHRSend.apply(this, arguments);
  }

  //override xhr open
  window.XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
    let stack = new Error().stack || '';
    if(isAuthorized(stack,url,"open","Xhr.open()")){
      return document._oldXHROpen.apply(this, arguments);
    }
  }


  //utils

  //--------------------------------------

  function isAuthorized(stack,url,fnName,logName){
    const isValid = stackValidator(stack, fnName);
    if (!isValid.valid) {
      writeToLogger(logName, url, isValid.file, true);
      return false;
    }
    writeToLogger(logName, url, isValid.file, false);
    return true;
  }

  /**
   * write to the log if the operation approved or blocked
   * @param { the name of the function } FnName 
   * @param { relevant to -> xhr / fetch } url 
   * @param { file of execution} fileName 
   * @param { status , blocked or approved} blocked 
   */
  function writeToLogger(FnName, url, fileName, blocked) {
    const logger = document._oldGetElementById("logger_tbody");
    const newNode = document.createElement("tr");
    const status = (blocked)?"Blocked":"Approved";
    if (blocked) {
      newNode.classList.add("logger_blocked", "logger_row");
    } else {
      newNode.classList.add("logger_approved", "logger_row");
    }
    newNode.innerHTML = `
      <td>${FnName}</td>
      <td>${fileName}</td>
      <td>${url}</td>
    `;
    logger.insertBefore(newNode, logger.firstChild);
  }


  /**
   * check if the file that Execute the function is Authorized
   * @param { call stack } stack 
   * @param { function name } name 
   */
  function stackValidator(stack, name) {
    let i = 0;
    stack = parseStack(stack);
    if(stack[i].includes("antiMalware.js")){
      i++;
    }
    //check in whiteList
    for(let j=0; j< window.whiteList.length;j++){
      if (stack[i].includes(window.whiteList[j])) {
        return { valid: true, file: "" };
      }
    }

    //if not in whiteList return valid:false
    const j = stack[i].lastIndexOf("/");
    const fileName = stack[i].substring(j, stack[i].length);
    // const regex = /(?<=)(.*)(?<=/)/g;
    // const file = stack[i].replace(regex,"");
    return { valid: false, file: fileName };
  }

  /**
   * parse the call stack 
   * @param {call stack} stack 
   * @returns array
   */
  function parseStack(stack) {
    stack = stack.split('\n');
    if (stack[0] == "Error") {
      stack.shift();
    }
    stack = stack.map((row) => row.trim().replace("at", ""));
    return stack;
  }
  
})();

