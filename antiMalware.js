(function () {

  const oldXHROpen = window.XMLHttpRequest.prototype.open;
  const oldXHRSend = window.XMLHttpRequest.prototype.send;
  const oldFetch = window.fetch;
  const oldGetItem = localStorage.getItem;
  document._oldGetElementById = document.getElementById;


  // document.querySelector
  // document.querySelectorAll
  // document.getElementsByClassName
  // document.getElementsByName
  // document.getElementsByTagName
  // document.getElementsByTagNameNS
  // document.insertBefore


  // let oldCookie = document.cookie;
  // document.cookie = (function(){
  //   return console.log("no hands no cookie :) ");
  // })();
  // document.writeCookie = function(data){  
  //   console.log(data);
  //   oldCookie = data;
  // } 
  // document.writeCookie("abcdefg");

 
  //getElementById override
  document.getElementById = function(){
    let stack = new Error().stack || '';
    const isValid = stackValidator(stack,"getElementById");
    const logger = document._oldGetElementById("logger_container");
    const newNode = document.createElement("div");
    let message = "";
    if(!isValid.valid){
      newNode.classList.add("logger_blocked","flex", "logger_row");
      message = `acess to getElementById was blocked , execute from file => ${isValid.file}`;
      return null;
    }else{
      newNode.classList.add("logger_approved","flex" , "logger_row");
      message = `getElementById , execute from file => ${isValid.file}`;
    }
    newNode.innerHTML = message;
    logger.insertBefore(newNode, logger.firstChild);

    return document._oldGetElementById(arguments[0]);
  }

  //localStorage override
  localStorage.getItem = function () {
    let stack = new Error().stack || '';
    const isValid = stackValidator(stack, "getItem");
    if (!isValid.valid) {
      writeToLogger(`localStorage`,"",isValid.file,true);
      return;
    }
    writeToLogger(`localStorage`,"",isValid.file,false);
    return oldGetItem.apply(this, arguments);
  }


  //ovrride fetch
  window.fetch = function () {
    const url = arguments[0];
    let stack = new Error().stack || '';
    const isValid = stackValidator(stack, "open");
    if (!isValid.valid) {
      writeToLogger(`Fetch`,url, isValid.file,true);
      return;
    }
    writeToLogger(`Fetch`,url, isValid.file,false);
    return oldFetch.apply(this, arguments)
  }



  //override xhr send
  window.XMLHttpRequest.prototype.send = function () {
    //prevent if open blocked 
    if (this.readyState == 0) {
      return;
    }
    return oldXHRSend.apply(this, arguments);
  }

  //override xhr open
  window.XMLHttpRequest.prototype.open = function (method, url, async, user, password) {
    let stack = new Error().stack || '';
    const isValid = stackValidator(stack, "open");
    if (!isValid.valid) {
      writeToLogger(`Xhr`,url,isValid.file,true);
      return;
    }
    writeToLogger(`Xhr`,url,isValid.file,false);
    return oldXHROpen.apply(this, arguments);
  }


  //utils

  //--------------------------------------
  function writeToLogger(FnName, url, fileName, blocked) {
    const logger = document._oldGetElementById("logger_container");
    //const logger = document.getElementById("logger_container");
    const newNode = document.createElement("div");
    if(blocked){
      newNode.classList.add("logger_blocked","flex", "logger_row");
      newNode.innerHTML = `[${FnName}]   <b>Blocked</b>  | ${url} | ${fileName}`;
    }else{
      newNode.classList.add("logger_approved","flex" , "logger_row");
      newNode.innerHTML = `[${FnName}]   <b>Approved</b>  | ${url} | ${fileName}`;
    }
    logger.insertBefore(newNode, logger.firstChild);
  }


  function stackValidator(stack, name) {
    let i = 0;
    stack = parseStack(stack);
    if (stack[i].includes(name)) {
      i++;
    }
    if (!stack[i].includes("antiMalware.js")) {
      const j = stack[i].lastIndexOf("/");
      const fileName = stack[i].substring(j, stack[i].length);
      // const regex = /(?<=)(.*)(?<=/)/g;
      // const file = stack[i].replace(regex,"");
      return { valid: false, file: fileName };
    }
    return { valid: true, file: "" };
  }

  function parseStack(stack) {
    stack = stack.split('\n');
    if (stack[0] == "Error") {
      stack.shift();
    }
    stack = stack.map((row) => row.trim().replace("at", ""));
    return stack;
  }

})();

